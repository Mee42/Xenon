= Xenon, a Native C-Like Language

Xenon is a language that is similar to C.
It compiles to basic assembly, which can be assembled to x64 instructions.

Some helpful Links: link:help[man pages]. link:resources[Resources]

== Language Design

This language will look similar to C.
At the top level, there will be a list functions. Functions look like this:

[source,xenon]
----
@foo int get(int i, int* array) {
    return *(array + i);
}
----


Here are how functions are defined:

. Functions are always started with their return type (`int`), precluded with any function annotations (`@foo`)
. The name of the function, which must start with a lowercase letter.
. A list of arguments. Each has:
.. A type. In this example, there is `int` and `int*`. `int*` is a mutable pointer to an int.
.. The name of the argument.
. A block of code in brackets.

=== Expressions

NOTE: Blocks are _not_ expressions. This is a choice made to reduce complexity.

Expressions follow a couple simple rules.

* Any variable identifier,
ie `foo`
* Any operator between two expressions,
ie `foo + bar`
** This includes the `.` operator, which is for member values, such like `foo.bar` (broke in latest commit)
* Parentheses with optional expressions comma-delimited in them,
ie `foo()`, `bar(a, b, c)`
* A asterisk before any expression that has a pointer type,
ie `\*array`, `*(array + 7)`. This is a dereference.

Assignments are statements, not expressions.
Assignments can be one of these:

[source, xenon]
----
val a     = 1 // this is immutable
mut val b = 1 // this is mutable
a = 7         // this is not allowed, as a is immutable
b = 7         // this is allowed, as b is mutable
----

When something is mutable, it means the local variable can be changed.
The value at the pointer has no such guarantee.

Type can be strictly enforced by using the type in place of `val`.
[source, xenon]
----
int64 x     = 10
mut ubyte y = 42 // this value is mutable
int32 z     = x  // this will error, because x is not an int32
----

Assignments *are expressions* and are typed in the form of:
[source, xenon]
----
$LVALUE = $RVALUE
----
An LValue is an expression that could we written to.

Examples of LValues include: `foo`, `*foo`, `foo.bar`.
Values that are not LValues include: `7`, `foo + 1`, `*foo.bar + 7`

If you wish to set something at the address of a pointer, you must use the `*` operator.

[source, xenon]
----
*array = 2
*(array + 1) = 3
int** array = someFunction()
*(*array) = 5
// or
**array = 5
----

Assignments are expressions, meaning `a = b = 7` will compile (though it is not encoraged)

Identifiers that start with `_` are inserted by the compiler and are not allowed in the source code.

All 4 math functions have been implemeonted for the int32 type: addition, subtraction, multiplication, and division,
as well as addition and subtraction for pointer types.
This addition respects the size of the underlying type and will properly increment the pointer so there is no overlap.
Division is normal integer division, so `3 / 2` is `1`.

The `==` and `!=` operators are also implemented, meaning equals and not equals respectivly.


== Mutable and Immutable pointers

Many problems in C arise from the fact that there is no compile-time semetic analysis
to catch immutable pointers issues.

Now, you might assume that an immutable pointer will always point to the same data.
This could be very helpful, for example, returning the substring of a string by moving the pointer around.
The issue with this is that no data in C is ever truly immutable as it's all either
(A) popped off the stack, or (B) ``free``d after being ``malloc``ed, making it not truly immutable.

Xenon solves this by not having immutable pointers, but instead "read-only pointers".
The syntax is similar to a pointer, but instead of an `*` there is a `+`.
This does not garentee that the data is immutable - but it doesn't let the caller write to it.

It's like a type-level garentee that a given function doesn't mutate memory at the location passed in.
For example, to get the length of a `char*`, no writing is needed.
So instead, the type is specified as `char+`, and it'll work the same.

This also allows you to make sure you know what functions mutate memory -
as it needs to have a mutable pointer type.

This is a feature that has been implemented successfully as of the latest commit.


== Current Issues

There are many things that you should be able to do that will crash with a NotImplementedException.
Because writing these down will lead to them being quickly outdated,
I'm only going to document shortcdivisionomings that will *not* crash the compiler.

* Functions are not checked to make sure they return, nor is the return type checked.
If functions do not return, the program will execute random instructions, and (most often) eventually segfault.
This will probably be fixed by/in the 0.2.0.


== Future plans

* Structs (being worked on now, planned for 0.2.0)

Structs are just values shoved next to each other. For example:
[source, xenon]
----
struct student {
    int gpa
    int age
}
----
__I'll take a page out of my CS professor's book and quantify students by GPA as a joke__

In memory and assembly, this will literally be 8 bytes of data, and each can be fetched invididually

The difficulty with structs is twofold:

1) proper lvalue support is needed to support complex struct member assigment. For example:

[source, xenon]
----
struct a { b bar }
struct b { int baz }
a foo = // whatever
foo.bar.baz = 7
----
The compiler has been refactored to allow for lvalues,
but member-access has not yet been coded (as structs have not been coded yet)

2) the A register cannot be used to propogate values from expressions.

This is pretty simple. In the past, the expression `foo() + 1` could just do:

[source, assembly]
----
call foo // return value is in the eax register
add eax, eax
// return value is left in the eax register
----

With structs that can be bigger than 8 bytes, this just doesn't work at all,
so the value propogation system needs a revamp to support a different method of
value passing.