= Xenon, a Native C-Like Language

Xenon is a language that is similar to C.
It compiles to basic assembly, which can be assembled to x64 instructions.

Code will run through a pipeline consisting of a:

[horizontal]

Preprocessor:: Think ``#define``s in C - runs before any lexing/parsing.
Lexer:: Take the source and create a list of tokens.
Parser Pass 1:: Parses an `InitialAST` that has everything but function bodies parsed.
Parser Pass 2:: Take the `InitialAST` and assemble a full AST. This also does type checking.
Optimizer:: Optimize said AST to avoid doing dumb stuff.
Assembler:: Tke the AST and turn it into assembly.
Nasm Assembler:: Take an asm file and turns it into x64.

Of all of these, the only one which will not be custom-made is the nasm assembler.
This is a design choice made to make this language more debuggable,
and could change once the project is more developed.

Different "pipes" will be kept in different packages: `xpp` (the preprocessor) ,`lexer`, `parser`, `opt` (optimizer), and `asm` (the assembler)

== Language Design

This language will look similar to C.
At the top level, there will be a list functions. Functions look like this:

[source,c]
----
function @pure get(@foo @bar unsigned int i, int* array) int {
    return *(array + i);
}
----


Here are how functions are defined:

. Functions are always started with the keyword `function`.
. All function attributes (attributes are prefixed with an `@`).
. The name of the function, which must start with a lowercase letter.
. A list of arguments. Each has:
.. A list of argument attributes (same as function attributes)
.. A list of one-or-more _type identifiers_. In this example, it is `unsigned int`
.. The name of the argument
. The return type of the function. this can, again, be one-or-more type identifiers
. A block of code in brackets.

=== Expressions

NOTE: Blocks are _not_ expressions. This is a choice made to reduce complexity.

Expressions follow a couple simple rules.

* Any variable identifier,
ie `foo`
* Any operator between two expressions,
ie `foo + bar`
** This includes the `.` operator, which is for member values
* Parentheses with optional expressions comma-delimited in them,
ie `foo()`, `bar(a, b, c)`
* A asterisk before any expression that has a pointer type,
ie `\*array`, `*(array + 7)`. This is a dereference

Assignments are statements, not expressions.
Assignments can be one of these:

[source, c]
----
val a = foo // this is immutable
var b = foo // this is mutable
a = bar     // this is not allowed, as a is immutable
b = bar     // this is allowed, as b is mutable
----

When something is mutable, it means the local variable can be changed.
The value at the pointer has no such guarantee.

If you wish to set something at the address of a pointer, you must use the `*` operator.

[source, c]
----
*array = 2
*(array + 1) = 3
// if array is an int**
**array = 5
----
All assignments must either be to a direct variable or a dereferenced pointer expression.

All complex assignments are parsed like:

[source, c]
----
*foo() = bar()
*baz() = boo()
// turns into
var _ptr_temp = foo()
*_ptr_temp = bar()
_ptr_temp = baz()
*_ptr_temp = boo()
----
Assignments are _not_ expressions, meaning that `a = b = 7` will not compile.

Identifiers that start with `_` are inserted by the compiler and are not allowed in the source code.

== Compiling to Assembly

Each function is defined with a label equal to it's name.
Here is an example function:

[source, c]
----
function double(int64 x) int64 {
    return x + x;
}
----
This will compile to the following assembly:
[source, asm]
----
double: ; return value in rax
    ; argument 0 (x) in register rbx
    add rbx, rbx
    mov rax, rbx
    ret
----
arguments will be past in these registers, in order: `rbx`, `rcx`, `rdx`, `r8`, `r9`
Only 5 arguments are supported at this time.
Return value is stored in `rax`.
Pointers are always 64 bits,
where as smaller values can be stored in bigger registers and used properly.

**Concept of ownership:** The function calling can depend on all registers (except `A`) staying the same.
The function being called needs to push all of the registers that it manipulates to the stack,
and then pop the same registers in order the same order before returning from the function.
This does not include argument parameters - ie, this is valid:
[source, asm]
----
quadruple:
    add rbx, rbx
    add rbx, rbx
    mov rax, rbx
    ret
----
This is not valid:
[source, asm]
----
func:
    mov r10, rbx
    add r10, rbx
    add r10, rbx
    mov rax, r10
    ret
----

Because this compiles to assembly, the compiler can output relevant context as comments in the assembly code,
which helps debugging.
In the assembly example above, the comments were generated by the compiler,
and not handwritten.

== Current Issues

There are many things that you should be able to do that will crash with a NotImplementedException.
Because writing these down will lead to them being quickly outdated,
I'm only going to document shortcomings that will *not* crash the compiler.

* Functions are not checked to make sure they return, nor is the return type checked