= Xenon, a Native C-Like Language

Xenon is a language that is similar to C.
It compiles to basic assembly, which can be assembled to x64 instructions.

Some helpful Links: link:help[man pages]. link:resources[Resources]

== Language Design

This language will look similar to C.
At the top level, there will be a list functions. Functions look like this:

[source,xenon]
----
@foo int get(int i, int* array) {
    return *(array + i);
}
----


Here are how functions are defined:

. Functions are always started with their return type (`int`), precluded with any function annotations (`@foo`)
. The name of the function, which must start with a lowercase letter.
. A list of arguments. Each has:
.. A type. In this example, there is `int` and `int*`. `int*` is a mutable pointer to an int.
.. The name of the argument.
. A block of code in brackets.

=== Expressions

NOTE: Blocks are _not_ expressions. This is a choice made to reduce complexity.

Expressions follow a couple simple rules.

* Any variable identifier,
ie `foo`
* Any operator between two expressions,
ie `foo + bar`
** This includes the `.` operator, which is for member values, such like `foo.bar`
* Parentheses with optional expressions comma-delimited in them,
ie `foo()`, `bar(a, b, c)`
* A asterisk before any expression that has a pointer type,
ie `\*array`, `*(array + 7)`. This is a dereference.

Assignments are statements, not expressions.
Assignments can be one of these:

[source, xenon]
----
val a     = 1 // this is immutable
mut val b = 1 // this is mutable
a = 7     // this is not allowed, as a is immutable
b = 7     // this is allowed, as b is mutable
----

When something is mutable, it means the local variable can be changed.
The value at the pointer has no such guarantee.

Type can be strictly enforced by using the type in place of `val`.
[source, xenon]
----
int64 x     = 10
mut ubyte y = 42 // this value is mutable
int32 z     = x  // this will error, because x is not an int32
----

If you wish to set something at the address of a pointer, you must use the `*` operator.

[source, xenon]
----
*array = 2
*(array + 1) = 3
int** array = someFunction()
*(*array) = 5
// or
**array = 5
----
All assignments must either be to a direct variable or a dereferenced pointer expression.
`5 = 3` won't compile (as it should).

Assignments are _not_ expressions, meaning that `a = b = 7` will not compile.

Identifiers that start with `_` are inserted by the compiler and are not allowed in the source code.

== Current Issues

There are many things that you should be able to do that will crash with a NotImplementedException.
Because writing these down will lead to them being quickly outdated,
I'm only going to document shortcomings that will *not* crash the compiler.

* Functions are not checked to make sure they return, nor is the return type checked.
If functions do not return, the program will execute random instructions, and probably segfault.

== Future plans

* Structs
* Immutable and mutable pointer types.
**  The idea being that `int+` is an immutable int pointer, and `int*` is a mutable int pointer.
    Though, being an immutable pointer does not mean the value is constant
    (as this would have very limited use),
    it instead just means the holder of the pointer is not allowed - and won't, ever - write to it.
    There will be no way to cast an `int+` to an `int*` without an `@unsafeImmutablePointer` attribute
    on the function.