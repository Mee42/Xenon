// suppress inspection "GrazieInspection"
= Xenon, a Native C-Like Language

Xenon is a language that is similar to C.
It compiles to NASM assembly, which can be assembled to x64 instructions.

Some helpful Links: link:help[man pages]. link:resources[Resources]


Before we dive into the language, Hello World:
[source, xenon]
----
int main(){
    println("Hello, World!")
    return 0
}
----


== Language Design

This language will look similar to C.
At the top level, there will be a list functions. Functions look like this:

[source,xenon]
----
int get(int* array, int i) {
    return *(array + i)
}
----

In Xenon, you write functions like this:

. Function definitions start with their return type (`int`), precluded with any function annotations (`@foo`)
. The name of the function, which must start with a lowercase letter.
. A list of arguments. Each has:
.. A type. In this example, there is `int` and `int+`. `int+` is a read-only pointer to an int.
.. The name of the argument.
. A block of code in brackets.

=== Expressions

NOTE: Blocks are _not_ expressions. This is a choice made to reduce complexity.

Expressions follow a couple simple rules.

* Any variable identifier,
ie `foo`
* Any operator between two expressions,
ie `foo + bar`
** This includes the `.` operator, which is for member values, such like `foo.bar`
* Parentheses with optional expressions comma-delimited in them,
ie `foo()`, `bar(a, b, c)`
* A asterisk before any expression that has a pointer type,
ie `\*array`, `*(array + 7)`. This is a dereference.
* An `&` symbol before a lvalue expression (see below for lvalue/rvalue).
This evaluates to the location of which the lvalue exists at, and is called "referencing".
`&array` would evaluate to a pointer type that points to where in memory `array` exists.
* Assigning a value to a lvalue, in the format of `lvalue = value`. `lvalue` can be any writable
lvalue, and value can be any value. If you have a variable `x`, you can set it with assignment `x = 7`.
Because assigments are expressions, `a = b = 7` is valid.

Declerations are Statements, not expression, and look like this:
[source, xenon]
----
val a     = 1 // this is immutable
mut val b = 1 // this is mutable
a = 7         // this is not allowed, as a is immutable
b = 7         // this is allowed, as b is mutable
----

When something is mutable, it means the local variable can be changed.
The value at the pointer has no such guarantee.

Type can be strictly enforced by using the type in place of `val`.
[source, xenon]
----
int64 x     = 10
mut ubyte y = 42 // this value is mutable
int32 z     = x  // this will error, because x is not an int32
----
Integers can be suffixed with their type (`b`=byte, `s`=short, `i`=integer,`l`=long)
and their sign (`u`=unsigned,` `=signed).

If you wish to set something at the address of a pointer, you must use the `*` operator.

[source, xenon]
----
*array = 2
*(array + 1) = 3
int** array = someFunction()
*(*array) = 5
// or
**array = 5
----

Identifiers that start with `_` are inserted by the compiler and are not allowed in the source code.
Some examples include `_ret_ptr`, whitch is used for passing back structs.

All 4 math functions have been implemented for the int32 type: addition, subtraction, multiplication, and division,
as well as addition and subtraction for pointer types.
This addition respects the size of the underlying type and will properly increment the pointer so there is no overlap.
Division is normal integer division, so `3 / 2` is `1`.

The `==` and `!=` operators have also been implemented, meaning equals and not equals respectivly.


== Mutable and Immutable pointers

Many problems in C arise from the fact that there is no compile-time semetic analysis
to catch pointers issues. Xenon introduces "immutable pointers", or "read-only pointers" to attempt to make this more usable.

Now, you might assume that an immutable pointer will always point to the same data.
This could be very helpful, for example, returning the substring of a string by moving the pointer around.
The issue with this is that no data in C is ever truly immutable, as eventually all data is
popped off the stack, and/or ``free``d after being ``malloc``ed, making it not truly immutable.

Xenon solves this by not having immutable pointers, but instead "read-only pointers".
The syntax is similar to a pointer, but instead of an `*` there is a `+`.
This does not garentee that the data is immutable - but it doesn't let code write to it.

It's like a type-level garentee that a given function doesn't mutate memory at the location passed in.
For example, to get the length of a `char*`, no mutation of memory is needed.
So instead, the type is specified as `char+`, and it'll work the same.

This also allows you to make sure you know what functions mutate memory, and which don't that ability.

A mutable pointer can be auto-degraded into an immutable pointer when passed as a function argument.


== Structs


Structs are just values shoved next to each other. For example:
[source, xenon]
----
struct Student {
    int gpa
    int age
}
----
In memory and assembly, this will literally be 8 bytes of data, and each can be fetched invididually

Struct type identifiers shoud be upper camal - ie `Student` or `TestResults`.
Structs can be assembled with the "struct assembly expression" - `Student{}`.
At the moment, if you have anything between the brackets, it'll incorrectly assume that it is a `if` statement and crash.
If you want to set the data at the struct, you'll need to write it to a variable and mutate it.

The initial status of members of a struct is undefined, so a "constructor" is often used.
A constructor has the same name as the struct, and returns a properly initualized struct of that type.


Using the `Student` struct from above.
[source, xenon]
----
Student Student(int age){
    val value = Student{} // initualize new struct
    value.gpa = -1 // unkown value
    value.age = age
}
----

Here's a simple list struct plus a constructor:
[source, xenon]
----
struct List {
    int length
    int allocated
    int* data
}
List List() {
    return list(10)
}
List List(int size){
    val l = List{}
    l.length = 0
    l.allocated = size
    l.data = malloc_int(size)
    return l
}
----

== Current Issues

There are many things that you should be able to do, but will crash the compiler (with a TODO) when attempetd.
These are features that have not been fully implemented yet.

Because writing these down will lead to them being quickly outdated,
I'm only going to document shortcomings that will *not* crash the compiler,
and that you need to be aware of in order to use Xenon.

* Functions are not checked to make sure they return, nor is the return type checked.
If functions do not return, the program will execute random instructions, and (most often) eventually segfault,
though some programs fall into an infinite loop.